"""
EUFCongruenceClosure: Congruence Closure Algorithm for Equality with Uninterpreted Functions (EUF)

This module implements the congruence closure algorithm as described in:
    "Congruence Closure with Integer Offsets" by Robert Nieuwenhuis and Albert Oliveras,
    Technical University of Catalonia, 2003.
    https://www.cs.upc.edu/~oliveras/dpllt.pdf

The algorithm efficiently computes the congruence closure of a set of ground equalities
and function applications, supporting the core reasoning required for EUF solvers in SMT
and DPLL(T) frameworks.

Key components:
    - Symbol: Represents variables or constants.
    - Function: Represents uninterpreted function symbols.
    - Apply: Application of a function to arguments (terms).
    - Eq / Neq: Equality and disequality atoms.
    - EUFCongruenceClosure: The core congruence closure engine.

The implementation is designed for integration with SymPy's SAT-based assumption system
and follows the data structures and logic outlined in the referenced paper.
"""

from dataclasses import dataclass
from typing import Any, Tuple, List, Dict, Deque, DefaultDict
from collections import defaultdict, deque

# --- Term and Atom Representation ---

@dataclass(frozen=True)
class Symbol:
    """
    Represents a variable or constant in the signature.
    """
    name: str

@dataclass(frozen=True)
class Function:
    """
    Represents an uninterpreted function symbol with a specified arity.
    """
    name: str
    arity: int

@dataclass(frozen=True)
class Apply:
    """
    Represents the application of a function to one or more arguments.

    Parameters
    ----------

    func : Function
        The function symbol being applied.
    args : Tuple[Any, ...]
        The arguments (Symbols or nested Apply objects).
    """
    func: Function
    args: Tuple[Any, ...]  # args are Symbol or Apply

def _sym(name: str) -> Symbol:
    """Convenience constructor for Symbol."""
    return Symbol(name)

def _func(name: str, arity: int = 1) -> Function:
    """Convenience constructor for Function."""
    return Function(name, arity)

def _apply(func: Function, *args: Any) -> Apply:
    """
    Constructs an Apply term, ensuring arity matches.

    Parameters
    ----------

    func : Function
        The function symbol.
    *args : Any
        The arguments to the function.

    Returns
    -------

    Apply
    """
    assert func.arity == len(args), f"Function {func.name} expects {func.arity} args, got {len(args)}"
    return Apply(func, args)

@dataclass(frozen=True)
class Eq:
    """
    Represents an equality atom between two terms.
    """
    left: Any
    right: Any

@dataclass(frozen=True)
class Neq:
    """
    Represents a disequality atom between two terms.
    """
    left: Any
    right: Any

def _Eq(left: Any, right: Any) -> Eq:
    """Convenience constructor for Eq."""
    return Eq(left, right)

def _Neq(left: Any, right: Any) -> Neq:
    """Convenience constructor for Neq."""
    return Neq(left, right)

# --- Congruence Closure Engine ---

class EUFCongruenceClosure:
    """
    Implements the O(n log n) congruence closure algorithm for ground EUF.

    This class maintains the equivalence classes of terms under the congruence
    generated by a set of equalities and function applications. It supports efficient
    queries and incremental addition of equalities.

    Parameters
    ----------

    eqs : List[Any]
        A list of Eq objects (and/or Apply terms) representing the input equations.

    Attributes
    ----------

    _id_of : Dict[Any, int]
        Maps each term to a unique integer id.
    _term_of : List[Any]
        Maps ids back to terms.
    rep : List[int]
        Union-find representative array.
    rank : List[int]
        Union-by-rank optimization.
    cls : List[List[int]]
        Class lists for each equivalence class.
    lookup : Dict[Tuple[Function, Tuple[int, ...]], int]
        Maps (function, tuple of argument reps) to result id.
    use : Dict[int, List[Tuple[Function, Tuple[Any, ...], int]]]
        For each id, tracks where it appears as an argument.
    _pending : deque
        Queue of pairs of ids to merge.
    """

    def __init__(self, eqs: List[Any]):
        # Maps terms to unique ids and vice versa
        self._id_of: Dict[Any, int] = {}
        self._term_of: List[Any] = []
        self.lookup: Dict[Tuple[Function, Tuple[Any, ...]], int] = {}
        self.use: DefaultDict[int, List[Tuple[Function, Tuple[Any, ...], int]]] = defaultdict(list)
        self._pending: Deque[Tuple[int, int]] = deque()

        def _cid(term):
            """Assigns and returns a unique integer id for each term."""
            if term not in self._id_of:
                self._id_of[term] = len(self._term_of)
                self._term_of.append(term)
            return self._id_of[term]

        # Union-find structures
        n_hint = 2 * len(eqs) + 1  # Heuristic for initial array sizes
        self.rep = list(range(n_hint))      # Representative array
        self.rank = [0] * n_hint           # Union-by-rank array
        self.cls = [[i] for i in range(n_hint)]  # Class lists

        # Congruence closure tables
        self.lookup = {}  # (func, tuple of arg ids) -> result id
        self.use = defaultdict(list)  # id -> list of function applications
        self._pending = deque()  # Queue of (id, id) pairs to merge

        # Flatten and process equations
        for eq in eqs:
            if isinstance(eq, Eq):
                # Process equality: flatten both sides and add to pending
                i = _cid(self._flatten(eq.left, _cid))
                j = _cid(self._flatten(eq.right, _cid))
                self._pending.append((i, j))
            elif isinstance(eq, Apply):
                # For function applications, ensure all subterms are assigned ids
                _cid(self._flatten(eq, _cid))

        self._process_pending_unions()

    def _flatten(self, term, _cid):
        """
        Recursively assigns ids to all subterms and builds lookup/use tables.

        Parameters
        ----------

        term : Any
            The term to flatten (Symbol, Function, or Apply).
        _cid : Callable
            Function to assign/get ids.

        Returns
        -------

        Any
            The flattened term (with ids assigned).
        """
        if isinstance(term, (Symbol, Function)):
            _cid(term)  # Ensure id assignment
            return term
        elif isinstance(term, Apply):
            flat_args = tuple(self._flatten(arg, _cid) for arg in term.args)
            flat_apply = Apply(term.func, flat_args)
            _cid(flat_apply)  # Ensure id assignment for the application itself
            # Register all argument ids and update use/lookup tables
            for arg in flat_args:
                _cid(arg)
                self.use[self._id_of[arg]].append((term.func, flat_args, self._id_of[flat_apply]))
            self.lookup[(term.func, tuple(self._id_of[arg] for arg in flat_args))] = self._id_of[flat_apply]
            return flat_apply
        else:
            _cid(term)
            return term

    def _find(self, i: int) -> int:
        """
        Finds the representative of the class containing id i, with path compression.

        Parameters
        ----------

        i : int
            The id to find the representative for.

        Returns
        -------

        int
            The representative id.
        """
        while self.rep[i] != i:
            self.rep[i] = self.rep[self.rep[i]]
            i = self.rep[i]
        return i

    def _union(self, i: int, j: int):
        """
        Merges the equivalence classes of i and j.

        Parameters
        ----------
        i, j : int
            The ids to merge.
        """
        i, j = self._find(i), self._find(j)
        if i == j:
            return
        # Union by rank for efficiency
        if self.rank[i] < self.rank[j]:
            i, j = j, i
        self.rep[j] = i
        if self.rank[i] == self.rank[j]:
            self.rank[i] += 1
        # Merge class lists and propagate congruence
        self.cls[i].extend(self.cls[j])
        self.cls[j].clear()
        self._merge_effects(i, j)

    def _process_pending_unions(self):
        """
        Processes all pending unions, merging classes and propagating congruence.
        """
        while self._pending:
            i, j = self._pending.popleft()
            self._union(i, j)

    def _merge_effects(self, ra: int, rb: int):
        """
        After merging classes ra and rb, checks all function applications where
        one of the reps appears. If two applications now have all arguments equal,
        their results must also be merged.

        Parameters
        ----------

        ra, rb : int
            The ids of the merged class representatives.
        """
        for r in (ra, rb):
            tmp = self.use.pop(r, [])
            for (func, arg_terms, res_id) in tmp:
                # Find representatives for all argument terms
                rep_args = tuple(self._find(self._id_of[arg]) for arg in arg_terms)
                key = (func, rep_args)
                if key in self.lookup:
                    # If this application already exists, merge their results
                    self._pending.append((res_id, self.lookup[key]))
                else:
                    # Otherwise, register this application for future merges
                    self.lookup[key] = res_id
                    for aid in rep_args:
                        self.use[aid].append((func, rep_args, res_id))

    def add_equality(self, t1: Any, t2: Any):
        """
        Adds an equality between two terms and processes the resulting congruence.

        Parameters
        ----------

        t1, t2 : Any
            The terms to be equated.
        """
        i, j = self._id_of[t1], self._id_of[t2]
        self._pending.append((self._find(i), self._find(j)))
        self._process_pending_unions()

    def are_equal(self, t1: Any, t2: Any) -> bool:
        """
        Checks if two terms are in the same equivalence class.

        Parameters
        ----------
        t1, t2 : Any
            The terms to compare.

        Returns
        -------
        bool
            True if t1 and t2 are congruent, False otherwise.
        """
        if t1 not in self._id_of or t2 not in self._id_of:
            return False
        return self._find(self._id_of[t1]) == self._find(self._id_of[t2])
